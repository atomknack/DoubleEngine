<#@ template language="C#" #>
<#@ output extension=".gen.cs" #>
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
<#@ include file="$(ProjectDir)\..\Project\_Include\_0_AssemplyImports.ttinclude" #>
<#@ include file="$(ProjectDir)\..\Project\_Include\_2_GlobalTTInclude.ttinclude" #>
<#@ include file="$(ProjectDir)\..\Project\_Include\_4_typeDeclaration.ttinclude" #>

<#@ include file="$(ProjectDir)\..\Project\_Include\_6_Vector2Unity_typeInitialization.ttinclude" #>
<#@ include file="$(ProjectDir)\..\Project\_Include\_6_Vector3Unity_typeInitialization.ttinclude" #>
<#@ include file="$(ProjectDir)\..\Project\_Include\_6_Vector4Unity_typeInitialization.ttinclude" #>
<#@ include file="$(ProjectDir)\..\Project\_Include\_InlineFunctions_ClassFeatures.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace <#=globalNamespaceName#>.UHelpers
{
    public static partial class UnityExtension
    {
/////////////////////////////
//<#=aInline#> 
//<#=publicStatic#> <#=b.type#> 
//<#=typeName#> <#=String.Join(" + ",fieldNames.Select(x=> $"{math["Abs"]}(a.{x})"))#>
/////////////////////////////

<# 

string extensionMethodThis = "this ";
string epsilonDistance;
string epsilonSqrDistance;

for(var a = 0; a<availableTypes.Count; a++)
    {
    UnfoldTypeDescription(availableTypes[a]);
    epsilonDistance = "1E-5"+ b.valueEnding;
    epsilonSqrDistance = "1E-9"+ b.valueEnding;
#>
//
    <#=aInline1CRLF4s#><#=publicStatic#> <#=typeName#> AddedVect(<#=extensionMethodThis#><#=typeName#> v, <#=inMod#><#=typeName#> vector) => <#=VectorVectorOperation("v.", "vector.", "+")#>
    <#=aInline1CRLF4s#><#=publicStatic#> <#=typeName#> Multiplied(<#=extensionMethodThis#><#=typeName#> v, <#=b.type#> scalar) => <#=VectorScalarOperation("v.", "scalar", "*")#>
    <#=aInline1CRLF4s#><#=publicStatic#> <#=typeName#> MultipliedVect(<#=extensionMethodThis#><#=typeName#> v, <#=inMod#><#=typeName#> vector) => new <#=typeName#> ( <#=String.Join(", ",fieldNames.Select(x=> $"v.{x} * vector.{x}"))#> );
    <#=aInline1CRLF4s#><#=publicStatic#> <#=typeName#> DividedBy(<#=extensionMethodThis#><#=typeName#> v, <#=b.type#> divider) => new <#=typeName#> ( <#=String.Join(", ",fieldNames.Select(x=> $"v.{x} / divider"))#> );
    <#=aInline1CRLF4s#><#=publicStatic#> <#=typeName#> DividedByVect(<#=extensionMethodThis#><#=typeName#> v, <#=inMod#><#=typeName#> divider) => new <#=typeName#> ( <#=String.Join(", ",fieldNames.Select(x=> $"v.{x} / divider.{x}"))#> );
    <#=aInline1CRLF4s#><#=publicStatic#> <#=typeName#> RemainderOfDivision(<#=extensionMethodThis#><#=typeName#> v, <#=b.type#> divider) => new <#=typeName#> ( <#=String.Join(", ",fieldNames.Select(x=> $"v.{x} % divider"))#> );
    <#=aInline1CRLF4s#><#=publicStatic#> <#=typeName#> RemainderOfDivisionVect(<#=extensionMethodThis#><#=typeName#> v, <#=inMod#><#=typeName#> divider) => new <#=typeName#> ( <#=String.Join(", ",fieldNames.Select(x=> $"v.{x} % divider.{x}"))#> );

//
<# } #>
    }
}
