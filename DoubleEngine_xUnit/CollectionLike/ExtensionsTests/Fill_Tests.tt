<#/*THIS IS A T4 FILE*/#>
<#@ template language="C#" #>
<#@ output extension=".gen.cs" #>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.

using DjvuNet.Tests.Xunit;
using DoubleEngine_xUnit.Helpers;
using FluentAssertions;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Collections.Pooled;
using CollectionLike;
using CollectionLike.Pooled;

namespace DoubleEngine_xUnit.CollectionLike.ExtensionsTests
{
    public class Fill_Tests
    {
        static int[] numOfElements = new[] { 0, 8, 1, 18, 2, 28, 9, 38, 99, 48, 113, 58, 260, 68 };
        public static IEnumerable<object[]> NumOfElements => numOfElements.WrapAs2Parameter();

<# 
string baseTypeName = "Vec3D";
(string name, string varName, string initializer, string count)[] testTypes = new[]
    {
    ("SpanInt", "Span<int>", "new int[count]", "Length"),
    ("ArrayInt", "int[]", "new int[count]", "Length"),
    ("PooledArrayStructInt", "PooledArrayStruct<int>", "new PooledArrayStruct<int>(count)", "Count"),
    };

for (var a = 0; a<testTypes.Length; ++a)
    {
        var tt = testTypes[a];
#>
        [DjvuTheory]
        [MemberData(nameof(NumOfElements))]
        public static void Fill_<#=tt.name#>_Test(int count, int fillValue)
        {
            <#=tt.varName#> elements = <#=tt.initializer#>;
            elements.Fill(fillValue);
            elements.<#=tt.count#>.Should().Be(count);
            for(int i = 0; i < count; ++i)
            {
                elements[i].Should().Be(fillValue);
            }
        }

        [DjvuTheory]
        [MemberData(nameof(NumOfElements))]
        public static void FillAsRange_<#=tt.name#>_Test(int count, int fillValue)
        {
            <#=tt.varName#> elements = <#=tt.initializer#>;
            elements.FillAsRange();
            elements.<#=tt.count#>.Should().Be(count);
            for(int i = 0; i < count; ++i)
            {
                elements[i].Should().Be(i);
            }

            elements.FillAsRange(fillValue);
            elements.<#=tt.count#>.Should().Be(count);
            for(int i = 0; i < count; ++i)
            {
                elements[i].Should().Be(i+fillValue);
            }
        }
<# } #>
    }
}
