//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

namespace DoubleEngine
{
    public partial class RemapperRegistryIndex
    {
        private Dictionary<RegistryIndex, int> remap;
        private int count;

        public Dictionary<RegistryIndex,int>.KeyCollection GetItemsToRemap() => remap.Keys;
        public int GetCount() => count;
        public int GetRemappedForExisting(RegistryIndex itemToRemap) => remap[itemToRemap];
        
        public int GetRemappedOrAdd(RegistryIndex itemToRemap)
        {
            if (remap.TryGetValue(itemToRemap, out int result))
                return result;
            AddWithoutChecks(itemToRemap);
            return GetRemappedForExisting(itemToRemap);
        }
        
        public void Add(RegistryIndex itemToRemap)
        {
            if (remap.ContainsKey(itemToRemap))
                return;
            AddWithoutChecks(itemToRemap);
        }
        
#region // Add and Remap in bulk for array, span and list
        public void AddMany(RegistryIndex[] itemsToAdd)
        {
            for(int i = 0; i < itemsToAdd.Length; i++)
                Add(itemsToAdd[i]);
        }
        public int[] RemapExistingItems(RegistryIndex[] itemsToRemap)
        {
            int[] result = new int[itemsToRemap.Length];
            for(int i = 0; i < itemsToRemap.Length; i++)
                result[i] = GetRemappedForExisting(itemsToRemap[i]);
            return result;
        }
        public void AddMany(Span<RegistryIndex> itemsToAdd)
        {
            for(int i = 0; i < itemsToAdd.Length; i++)
                Add(itemsToAdd[i]);
        }
        public int[] RemapExistingItems(Span<RegistryIndex> itemsToRemap)
        {
            int[] result = new int[itemsToRemap.Length];
            for(int i = 0; i < itemsToRemap.Length; i++)
                result[i] = GetRemappedForExisting(itemsToRemap[i]);
            return result;
        }
        public void AddMany(List<RegistryIndex> itemsToAdd)
        {
            for(int i = 0; i < itemsToAdd.Count; i++)
                Add(itemsToAdd[i]);
        }
        public int[] RemapExistingItems(List<RegistryIndex> itemsToRemap)
        {
            int[] result = new int[itemsToRemap.Count];
            for(int i = 0; i < itemsToRemap.Count; i++)
                result[i] = GetRemappedForExisting(itemsToRemap[i]);
            return result;
        }
#endregion
#region // Constructors and Clearing
        public RemapperRegistryIndex(int initialRemapperInternalDictionaryCapacity)
        {
            remap = new Dictionary<RegistryIndex, int>(initialRemapperInternalDictionaryCapacity);
            count = 0;
        }
        public RemapperRegistryIndex()
        {
            remap = new Dictionary<RegistryIndex, int>();
            count = 0;
        }
        public void Clear_ToUseWithRelativerySameNumberOfItems()
        {
            remap.Clear();
            count = 0;
        }
#endregion
        private void AddWithoutChecks(RegistryIndex itemToRemap)
        {
            remap.Add(itemToRemap, count);
            count++;
        }

    }
}
