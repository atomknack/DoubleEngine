<#@ template language="C#" hostspecific="True"#>
<#@ output extension=".gen.cs" #>
<#@ include file="$(ProjectDir)\_Include\_0_AssemplyImports.ttinclude" #>

<#@ import namespace="System.IO" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>

<#@ include file="$(ProjectDir)\_Include\_1_ManagerMultipleOutputHelper.ttinclude"#>
<#@ include file="$(ProjectDir)\_Include\_2_GlobalTTInclude.ttinclude" #>
<# FileInfo t4FileInfo = new FileInfo( this.Host.TemplateFile );#>
//// this file was generated as byproduct of generating *.gen.cs files from master template: <#=t4FileInfo.Name#>

<# var manager = Manager.Create(Host, GenerationEnvironment); #>
<# 
string[] availableTypes = {"int", "RegistryIndex"};
string[] availableTypesTitles = {"Int", "RegistryIndex"};
object[] availableTypesIterators = new object[2];
//(string ListType, string Length)[] = new[]{("int[]", "Length"),("Span<int>", "Length"),("List<int>", "Count")}
availableTypesIterators[0] = new (string ListType, string Length)[]{("int[]", "Length"),("Span<int>", "Length"),("List<int>", "Count")};
availableTypesIterators[1] = new (string ListType, string Length)[]{
    ("RegistryIndex[]", "Length"),
    ("Span<RegistryIndex>", "Length"),
    ("List<RegistryIndex>", "Count")};

//string[] availableTypesValueGetters = {"", ".Value"};

for(var k = 0; k<availableTypes.Length; k++)
    {
    string typeName = availableTypes[k];
    string title = availableTypesTitles[k];
    (string ListType, string Length)[] typeIterators = ((string ListType, string Length)[])availableTypesIterators[k];

    string filename = $"Remapper_{title}.gen.cs";
    WriteLine($"//// Generating: {filename}");
    manager.StartNewFile(filename); #>
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

namespace DoubleEngine
{
    public partial class Remapper<#=title#>
    {
        private Dictionary<<#=typeName#>, int> remap;
        private int count;

        public Dictionary<<#=typeName#>,int>.KeyCollection GetItemsToRemap() => remap.Keys;
        public int GetCount() => count;
        public int GetRemappedForExisting(<#=typeName#> itemToRemap) => remap[itemToRemap];
        
        public int GetRemappedOrAdd(<#=typeName#> itemToRemap)
        {
            if (remap.TryGetValue(itemToRemap, out int result))
                return result;
            AddWithoutChecks(itemToRemap);
            return GetRemappedForExisting(itemToRemap);
        }
        
        public void Add(<#=typeName#> itemToRemap)
        {
            if (remap.ContainsKey(itemToRemap))
                return;
            AddWithoutChecks(itemToRemap);
        }
        
#region // Add and Remap in bulk for array, span and list
<# foreach((string ListType, string Length) listlike in typeIterators) { #>
        public void AddMany(<#=listlike.ListType#> itemsToAdd)
        {
            for(int i = 0; i < itemsToAdd.<#=listlike.Length#>; i++)
                Add(itemsToAdd[i]);
        }
        public int[] RemapExistingItems(<#=listlike.ListType#> itemsToRemap)
        {
            int[] result = new int[itemsToRemap.<#=listlike.Length#>];
            for(int i = 0; i < itemsToRemap.<#=listlike.Length#>; i++)
                result[i] = GetRemappedForExisting(itemsToRemap[i]);
            return result;
        }
<# } #>
#endregion
#region // Constructors and Clearing
        public Remapper<#=title#>(int initialRemapperInternalDictionaryCapacity)
        {
            remap = new Dictionary<<#=typeName#>, int>(initialRemapperInternalDictionaryCapacity);
            count = 0;
        }
        public Remapper<#=title#>()
        {
            remap = new Dictionary<<#=typeName#>, int>();
            count = 0;
        }
        public void Clear_ToUseWithRelativerySameNumberOfItems()
        {
            remap.Clear();
            count = 0;
        }
#endregion
        private void AddWithoutChecks(<#=typeName#> itemToRemap)
        {
            remap.Add(itemToRemap, count);
            count++;
        }

    }
}
<#  manager.EndBlock();
    } #>
<# manager.Process(true); #>