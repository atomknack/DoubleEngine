<#@ template language="C#" #>
<#@ output extension=".gen.cs" #>
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
<#@ include file="$(ProjectDir)\_Include\_0_AssemplyImports.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_2_GlobalTTInclude.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_4_typeDeclaration.ttinclude" #>

<#@ include file="$(ProjectDir)\_Include\_6_Vec2D_typeInitialization.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_6_Vec3D_typeInitialization.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_6_Vec4D_typeInitialization.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace <#=globalNamespaceName#>
{
    public static partial class VectorUtil
    {
<# 
var arrayIterators = new Func<string, string>[2];
arrayIterators[0] = x=>$"{x}[]";
arrayIterators[1] = x=>$"ReadOnlySpan<{x}>";


string epsilonDistance;
string epsilonSqrDistance;

for(var a = 0; a<availableTypes.Count; a++)
    {
    UnfoldTypeDescription(availableTypes[a]);
    epsilonDistance = "1E-5"+ b.valueEnding;
    epsilonSqrDistance = "1E-9"+ b.valueEnding;
#>
<# foreach(var iterator in arrayIterators) { #>
    public static bool In_CompareBySqrDistance(this <#=iterator(typeName)#> vertices, <#=typeName#> vertex, <#=b.type#> epsilonSqr = <#=epsilonSqrDistance#>)
    {
        for (var i = 0; i < vertices.Length; i++)
            if (vertex.CloseBySqrDistance(vertices[i], epsilonSqr))
                return true;
        return false;
    }

    public static bool In_CompareByEach(this <#=iterator(typeName)#> vertices, <#=typeName#> vertex, <#=b.type#> epsilon = <#=epsilonDistance#>)
    {
        for (var i = 0; i < vertices.Length; i++)
            if (vertex.CloseByEach(vertices[i], epsilon))
                return true;
        return false;
    }
    public static bool In_CompareByEach(this <#=iterator(typeName)#> vertices, <#=typeName#> vertex, out int verticeIndex, <#=b.type#> epsilon = <#=epsilonDistance#>)
    {
        for (var i = 0; i < vertices.Length; i++)
            if (vertex.CloseByEach(vertices[i], epsilon))
                {
                verticeIndex = i;
                return true;
                }
        verticeIndex=-1;
        return false;
    }

    public static bool InIndexes_CompareByEach(this <#=iterator("int")#> indexesToCompare, <#=iterator(typeName)#> vertices, <#=typeName#> vertex, out int indexOfPositionInIndexed, <#=b.type#> epsilon = <#=epsilonDistance#>)
    {
        for (var i = 0; i < indexesToCompare.Length; i++)
            if (vertex.CloseByEach(vertices[indexesToCompare[i]], epsilon))
                {
                indexOfPositionInIndexed = i;
                return true;
                }
        indexOfPositionInIndexed=-1;
        return false;
    }

    public static int Count_CompareBySqrDistance(this <#=iterator(typeName)#> vertices, <#=typeName#> vertex, <#=b.type#> epsilonSqr = <#=epsilonSqrDistance#>)
    {
        int count = 0;
        for (var i = 0; i < vertices.Length; i++)
            if (vertex.CloseBySqrDistance(vertices[i], epsilonSqr))
                count++;
        return count;
    }

    public static int Count_CompareByEach(this <#=iterator(typeName)#> vertices, <#=typeName#> vertex, <#=b.type#> epsilon = <#=epsilonDistance#>)
    {
        int count = 0;
        for (var i = 0; i < vertices.Length; i++)
            if (vertex.CloseByEach(vertices[i], epsilon))
                count++;
        return count;
    }
<# } #>
<# } #>
    }
}
