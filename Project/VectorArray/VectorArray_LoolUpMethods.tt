<#@ template language="C#" #>
<#@ output extension=".gen.cs" #>
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
<#@ include file="$(ProjectDir)\_Include\_0_AssemplyImports.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_2_GlobalTTInclude.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_4_typeDeclaration.ttinclude" #>

<#@ include file="$(ProjectDir)\_Include\_6_Vec2D_typeInitialization.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_6_Vec3D_typeInitialization.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_6_Vec4D_typeInitialization.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace <#=globalNamespaceName#>
{
    public static partial class VectorArray
    {
    //<#=aInline#> 
//<#=publicStatic#> <#=b.type#> 
//<#=typeName#> <#=String.Join(" + ",fieldNames.Select(x=> $"{math["Abs"]}(a.{x})"))#>
<# 

string epsilonEach = "1E-5"+ b.valueEnding;
string epsilonDistance = "1E-5"+ b.valueEnding;
string epsilonSqrDistance = "1E-9"+ b.valueEnding;

for(var a = 0; a<availableTypes.Count; a++)
    {
    UnfoldTypeDescription(availableTypes[a]);

    epsilonDistance = "1E-5"+ b.valueEnding;
    epsilonSqrDistance = "1E-9"+ b.valueEnding;

#>

    public static bool NotContainsCloseEnoughByEach(this <#=typeName#>[] vertices, <#=typeName#> vertex, <#=b.type#> epsilon = <#=epsilonEach#>)
    {
        for (var i = 0; i < vertices.Length; i++)
            if (vertex.CloseByEach(vertices[i], epsilon))
                return false;
        return true;
    }

    /// <summary>Compare 2 equal sized arrays by each vector component</summary>
    /// <exception cref="System.ArgumentNullException">To compare 2 vector array both of them should be not null</exception>
    public static bool CloseEnough(this <#=typeName#>[] a, <#=typeName#>[] b, <#=b.type#> epsilon = <#=epsilonEach#>)
    {
        if (a == null || b == null) throw new ArgumentNullException("To compare 2 vector array both of them should be not null");
        //if (a.Length != b.Length) throw new ArgumentException("Must compare 2 equal size vector array");
        // <exception cref="System.ArgumentException">Must compare 2 equal size vector array</exception>
        for (var i = 0; i < a.Length; i++)
            if (b.NotContainsCloseEnoughByEach(a[i], epsilon))
                return false;
        for (var j = 0; j < b.Length; j++)
            if (a.NotContainsCloseEnoughByEach(b[j], epsilon))
                return false;
        return true;
    }

    public static int CloseWithLowerIndexOrSelf(this <#=typeName#>[] vertices, int vertexIndex, <#=b.type#> epsilon = <#=epsilonEach#>)
    {
        <#=typeName#> vertex= vertices[vertexIndex];
        for (var i = 0; i < vertexIndex; i++)
            if (vertex.CloseByEach(vertices[i], epsilon))
                return i;
        return vertexIndex;
    }
    // need refactoring and testing    
    <#=publicStatic#> int ClosestOrFirstIndex(this <#=typeName#>[] vertices, <#=typeName#> vertex, int lookUpTo, <#=b.type#> sqrEpsilon = <#=epsilonSqrDistance#>)
    {
        for (var i = 0; i < lookUpTo; i++)
            if (vertex.CloseBySqrDistance(vertices[i], sqrEpsilon))
                return i;
        return lookUpTo;
    }

<# } #>

    /*
    [Obsolete("its not closest, its first close enought or return lookUpTo")]
    public static int ClosestOrLast(this Vector3[] vertices, Vector3 vertex, int lookUpTo, float epsilon = E_D)
    {
        for (var i = 0; i < lookUpTo; i++)
            if (vertex.CloseEnoughByEach(vertices[i], epsilon))
                return i;
        return lookUpTo;
    }
    */
    /* refactored, copy for reference
        /// <summary>Compare 2 equal sized arrays by each vector component</summary>
    /// <exception cref="System.ArgumentNullException">To compare 2 vector array both of them should be not null</exception>
    public static bool CloseEnough(this Vector2[] a, Vector2[] b, float epsilon = E_D)
    {
        if (a == null || b == null) throw new ArgumentNullException("To compare 2 vector array both of them should be not null");
        //if (a.Length != b.Length) throw new ArgumentException("Must compare 2 equal size vector array");
        // <exception cref="System.ArgumentException">Must compare 2 equal size vector array</exception>
        for (var i = 0; i < a.Length; i++)
            for (var j = 0; j < b.Length; j++)
            {
                if (a.NotContainsCloseEnoughByEach(b[j], epsilon) || b.NotContainsCloseEnoughByEach(a[i], epsilon))
                    return false;
            }
        return true;
    }
    */

    }
}
