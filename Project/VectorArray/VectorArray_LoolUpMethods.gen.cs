//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace DoubleEngine
{
    public static partial class VectorArray
    {
    //[MethodImpl(MethodImplOptions.AggressiveInlining)] 
//public static double 
//Vec4D Math.Abs(a.x) + Math.Abs(a.y) + Math.Abs(a.z) + Math.Abs(a.w)

    public static bool NotContainsCloseEnoughByEach(this Vec2D[] vertices, Vec2D vertex, double epsilon = 1E-5d)
    {
        for (var i = 0; i < vertices.Length; i++)
            if (vertex.CloseByEach(vertices[i], epsilon))
                return false;
        return true;
    }

    /// <summary>Compare 2 equal sized arrays by each vector component</summary>
    /// <exception cref="System.ArgumentNullException">To compare 2 vector array both of them should be not null</exception>
    public static bool CloseEnough(this Vec2D[] a, Vec2D[] b, double epsilon = 1E-5d)
    {
        if (a == null || b == null) throw new ArgumentNullException("To compare 2 vector array both of them should be not null");
        //if (a.Length != b.Length) throw new ArgumentException("Must compare 2 equal size vector array");
        // <exception cref="System.ArgumentException">Must compare 2 equal size vector array</exception>
        for (var i = 0; i < a.Length; i++)
            if (b.NotContainsCloseEnoughByEach(a[i], epsilon))
                return false;
        for (var j = 0; j < b.Length; j++)
            if (a.NotContainsCloseEnoughByEach(b[j], epsilon))
                return false;
        return true;
    }

    public static int CloseWithLowerIndexOrSelf(this Vec2D[] vertices, int vertexIndex, double epsilon = 1E-5d)
    {
        Vec2D vertex= vertices[vertexIndex];
        for (var i = 0; i < vertexIndex; i++)
            if (vertex.CloseByEach(vertices[i], epsilon))
                return i;
        return vertexIndex;
    }
    // need refactoring and testing    
    public static int ClosestOrFirstIndex(this Vec2D[] vertices, Vec2D vertex, int lookUpTo, double sqrEpsilon = 1E-9d)
    {
        for (var i = 0; i < lookUpTo; i++)
            if (vertex.CloseBySqrDistance(vertices[i], sqrEpsilon))
                return i;
        return lookUpTo;
    }


    public static bool NotContainsCloseEnoughByEach(this Vec3D[] vertices, Vec3D vertex, double epsilon = 1E-5d)
    {
        for (var i = 0; i < vertices.Length; i++)
            if (vertex.CloseByEach(vertices[i], epsilon))
                return false;
        return true;
    }

    /// <summary>Compare 2 equal sized arrays by each vector component</summary>
    /// <exception cref="System.ArgumentNullException">To compare 2 vector array both of them should be not null</exception>
    public static bool CloseEnough(this Vec3D[] a, Vec3D[] b, double epsilon = 1E-5d)
    {
        if (a == null || b == null) throw new ArgumentNullException("To compare 2 vector array both of them should be not null");
        //if (a.Length != b.Length) throw new ArgumentException("Must compare 2 equal size vector array");
        // <exception cref="System.ArgumentException">Must compare 2 equal size vector array</exception>
        for (var i = 0; i < a.Length; i++)
            if (b.NotContainsCloseEnoughByEach(a[i], epsilon))
                return false;
        for (var j = 0; j < b.Length; j++)
            if (a.NotContainsCloseEnoughByEach(b[j], epsilon))
                return false;
        return true;
    }

    public static int CloseWithLowerIndexOrSelf(this Vec3D[] vertices, int vertexIndex, double epsilon = 1E-5d)
    {
        Vec3D vertex= vertices[vertexIndex];
        for (var i = 0; i < vertexIndex; i++)
            if (vertex.CloseByEach(vertices[i], epsilon))
                return i;
        return vertexIndex;
    }
    // need refactoring and testing    
    public static int ClosestOrFirstIndex(this Vec3D[] vertices, Vec3D vertex, int lookUpTo, double sqrEpsilon = 1E-9d)
    {
        for (var i = 0; i < lookUpTo; i++)
            if (vertex.CloseBySqrDistance(vertices[i], sqrEpsilon))
                return i;
        return lookUpTo;
    }


    public static bool NotContainsCloseEnoughByEach(this Vec4D[] vertices, Vec4D vertex, double epsilon = 1E-5d)
    {
        for (var i = 0; i < vertices.Length; i++)
            if (vertex.CloseByEach(vertices[i], epsilon))
                return false;
        return true;
    }

    /// <summary>Compare 2 equal sized arrays by each vector component</summary>
    /// <exception cref="System.ArgumentNullException">To compare 2 vector array both of them should be not null</exception>
    public static bool CloseEnough(this Vec4D[] a, Vec4D[] b, double epsilon = 1E-5d)
    {
        if (a == null || b == null) throw new ArgumentNullException("To compare 2 vector array both of them should be not null");
        //if (a.Length != b.Length) throw new ArgumentException("Must compare 2 equal size vector array");
        // <exception cref="System.ArgumentException">Must compare 2 equal size vector array</exception>
        for (var i = 0; i < a.Length; i++)
            if (b.NotContainsCloseEnoughByEach(a[i], epsilon))
                return false;
        for (var j = 0; j < b.Length; j++)
            if (a.NotContainsCloseEnoughByEach(b[j], epsilon))
                return false;
        return true;
    }

    public static int CloseWithLowerIndexOrSelf(this Vec4D[] vertices, int vertexIndex, double epsilon = 1E-5d)
    {
        Vec4D vertex= vertices[vertexIndex];
        for (var i = 0; i < vertexIndex; i++)
            if (vertex.CloseByEach(vertices[i], epsilon))
                return i;
        return vertexIndex;
    }
    // need refactoring and testing    
    public static int ClosestOrFirstIndex(this Vec4D[] vertices, Vec4D vertex, int lookUpTo, double sqrEpsilon = 1E-9d)
    {
        for (var i = 0; i < lookUpTo; i++)
            if (vertex.CloseBySqrDistance(vertices[i], sqrEpsilon))
                return i;
        return lookUpTo;
    }


    /*
    [Obsolete("its not closest, its first close enought or return lookUpTo")]
    public static int ClosestOrLast(this Vector3[] vertices, Vector3 vertex, int lookUpTo, float epsilon = E_D)
    {
        for (var i = 0; i < lookUpTo; i++)
            if (vertex.CloseEnoughByEach(vertices[i], epsilon))
                return i;
        return lookUpTo;
    }
    */
    /* refactored, copy for reference
        /// <summary>Compare 2 equal sized arrays by each vector component</summary>
    /// <exception cref="System.ArgumentNullException">To compare 2 vector array both of them should be not null</exception>
    public static bool CloseEnough(this Vector2[] a, Vector2[] b, float epsilon = E_D)
    {
        if (a == null || b == null) throw new ArgumentNullException("To compare 2 vector array both of them should be not null");
        //if (a.Length != b.Length) throw new ArgumentException("Must compare 2 equal size vector array");
        // <exception cref="System.ArgumentException">Must compare 2 equal size vector array</exception>
        for (var i = 0; i < a.Length; i++)
            for (var j = 0; j < b.Length; j++)
            {
                if (a.NotContainsCloseEnoughByEach(b[j], epsilon) || b.NotContainsCloseEnoughByEach(a[i], epsilon))
                    return false;
            }
        return true;
    }
    */

    }
}
