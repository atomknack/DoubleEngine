<#@ template language="C#" #>
<#@ output extension=".gen.cs" #>
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
<#@ include file="$(ProjectDir)\_Include\_0_AssemplyImports.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_2_GlobalTTInclude.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_4_typeDeclaration.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace <#=globalNamespaceName#>
{
    public static partial class VectorArray
    {
<# 
(string fromType, string toType)[] conversions= 
    new []{
    ("Vec2D", "Vec3D"),
    ("Vec2I", "Vec3I"),
    };
string[] conversionBase = new[] {"double", "int"};

string fromType; 
string toType;

Func<string, string>[] thisDecorator = new Func<string, string>[3];
thisDecorator[0] = s => $"this {s}[]";
thisDecorator[1] = s => $"this ReadOnlySpan<{s}>";
thisDecorator[2] = s => $"this IReadOnlyList<{s}>";

string[] thisLengthName = new string[3];
thisLengthName[0] = "Length";
thisLengthName[1] = "Length";
thisLengthName[2] = "Count";

for(var a = 0; a<conversions.Length; a++)
    {
    //UnfoldTypeDescription(availableTypes[a]);
    (fromType, toType) = conversions[a];
    string baseType = conversionBase[a];
#>
<#for(var t = 0; t<thisDecorator.Length; t++){#>
        public static <#=fromType#>[] ConvertXYZtoXYArray(<#=thisDecorator[t](toType)#> vectors)
        {
            <#=fromType#>[] newArray = new <#=fromType#>[vectors.<#=thisLengthName[t]#>];
            for (int i = 0; i < vectors.<#=thisLengthName[t]#>; ++i)
                newArray[i] = new <#=fromType#>(vectors[i].x, vectors[i].y);
            return newArray;
        }
        public static <#=toType#>[] ConvertXYtoXYZArray(<#=thisDecorator[t](fromType)#> vectors, <#=baseType#> newZ)
        {
            <#=toType#>[] newArray = new <#=toType#>[vectors.<#=thisLengthName[t]#>];
            for (int i = 0; i < vectors.<#=thisLengthName[t]#>; ++i)
                newArray[i] = new <#=toType#>(vectors[i].x, vectors[i].y, newZ);
            return newArray;
        }
<# } #>

/*        public static <#=toType#>[] ConvertXYtoXYZArray<#=toType#>(this <#=fromType#>[] vectors, <#=baseType#> newZ)
        {
            <#=toType#>[] newArray = new <#=toType#>[vectors.Length];
            for (int i = 0; i < vectors.Length; ++i)
                newArray[i] = new <#=toType#>(vectors[i].x, vectors[i].y, newZ);
            return newArray;
        }
        public static <#=toType#>[] ConvertXYtoXYZArray<#=toType#>(this ReadOnlySpan<<#=fromType#>> vectors, <#=baseType#> newZ)
        {
            <#=toType#>[] newArray = new <#=toType#>[vectors.Length];
            for (int i = 0; i < vectors.Length; ++i)
                newArray[i] = new <#=toType#>(vectors[i].x, vectors[i].y, newZ);
            return newArray;
        }
        public static <#=toType#>[] ConvertXYtoXYZArray<#=toType#>(this IReadOnlyList<<#=fromType#>> vectors, <#=baseType#> newZ)
        {
            <#=toType#>[] newArray = new <#=toType#>[vectors.Count];
            for (int i = 0; i < vectors.Count; ++i)
                newArray[i] = new <#=toType#>(vectors[i].x, vectors[i].y, newZ);
            return newArray;
        }*/

<# } #>
    }
}
