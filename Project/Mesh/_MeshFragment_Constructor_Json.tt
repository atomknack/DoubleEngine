<#@ template language="C#" hostspecific="True"#>
<#@ output extension=".gen.cs" #>
<#@ include file="$(ProjectDir)\_Include\_0_AssemplyImports.ttinclude" #>

<#@ import namespace="System.IO" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>

<#@ include file="$(ProjectDir)\_Include\_1_ManagerMultipleOutputHelper.ttinclude"#>
<#@ include file="$(ProjectDir)\_Include\_2_GlobalTTInclude.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_4_typeDeclaration.ttinclude" #>

<#@ include file="$(ProjectDir)\_Include\_6_Vec2D_typeInitialization.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_6_Vec3D_typeInitialization.ttinclude" #>
<# // include file="$(ProjectDir)\_Include\_6_Vector3Unity_typeInitialization.ttinclude" #>
<# FileInfo t4FileInfo = new FileInfo( this.Host.TemplateFile );#>
//// this file was generated as byproduct of generating *.gen.cs files from master template: <#=t4FileInfo.Name#>

<# var manager = Manager.Create(Host, GenerationEnvironment); #>
<# 

Dictionary<string,string> fromDict = new Dictionary<string,string>();
fromDict["Vec2D"] = "Vector2";
fromDict["Vec3D"] = "Vector3";
fromDict["Vector3"] = "Vec3D";

Dictionary<string,bool> is3D = new Dictionary<string,bool>();
is3D["Vec2D"] = false;
is3D["Vec3D"] = true;
is3D["Vector3"] = true;

for(var k = 0; k<availableTypes.Count; k++)
    {
    UnfoldTypeDescription(availableTypes[k]);
    string filename = $"MeshFragment{typeName}_Constructor_Json.gen.cs";
    WriteLine($"//// Generating: {filename}");
    manager.StartNewFile(filename); #>
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a <#=t4FileInfo.Name#>
//     Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json;
using System;

namespace <#=globalNamespaceName#>
{
    [JsonObject(MemberSerialization.OptIn)]
    sealed public partial record MeshFragment<#=typeName#> : IMeshFragment<<#=typeName#>>
    {
        [JsonIgnore] internal static readonly <#=typeName#>[] EmptyVertices = new <#=typeName#>[0];
        [JsonIgnore] internal static readonly int[] EmptyTriangles = new int[0];

        [JsonIgnore] public static readonly MeshFragment<#=typeName#> Empty = new MeshFragment<#=typeName#>();

        private MeshFragment<#=typeName#>()
        {
            this.vertices = EmptyVertices;
            this.triangles = EmptyTriangles;
            this._joinedVertices = (<#=b.type#>) Single.MaxValue;
        }

        public bool Equals(MeshFragment<#=typeName#> other)
        {
        if(this is null || other is null)
            return false;
        if(vertices.Length == 0 && other.vertices.Length == 0)
            return true;
        //if ( (this?.vertices?.Length ?? 0) == 0 && (other?.vertices?.Length ?? 0) == 0 )
        //    return true;
	    return EqualityComparer<<#=typeName#>[]>.Default.Equals(vertices, other.vertices) && 
            EqualityComparer<int[]>.Default.Equals(triangles, other.triangles);
        }

        public override int GetHashCode()
        {
	        return ((EqualityComparer<Type>.Default.GetHashCode(EqualityContract) * -1521134295 + EqualityComparer<<#=typeName#>[]>.Default.GetHashCode(vertices)) * -1521134295 + EqualityComparer<int[]>.Default.GetHashCode(triangles));
        }



        [JsonProperty(Required = Required.Always)] internal readonly <#=typeName#>[] vertices;
        //[Obsolete("if you need to fiddle with vertices then probably is something wrong")]
        [JsonIgnore] public ReadOnlySpan<<#=typeName#>> Vertices { get {return new ReadOnlySpan<<#=typeName#>>(vertices);} }

        [JsonProperty(Required = Required.Always)] internal readonly int[] triangles;
        //[Obsolete("if you need to fiddle with triangles then probably is something wrong")]
        [JsonIgnore] public ReadOnlySpan<int> Triangles { get {return new ReadOnlySpan<int>(triangles);} }
        [JsonIgnore] public ReadOnlySpan<IndexedTri> Faces { get {return new ReadOnlySpan<int>(triangles).CastToIndexedTri_ReadOnlySpan();} }
        

        [JsonIgnore] internal readonly <#=b.type#> _joinedVertices = -1;

        private MeshFragment<#=typeName#>(<#=typeName#>[] vertices, int[] triangles)
        {
            this.vertices = vertices;//(Vector3[])vertexes.Clone();
            this.triangles = triangles;//(int[])triangles.Clone();
            Check();
        }

        [JsonConstructor]
        internal MeshFragment<#=typeName#>(<#=typeName#>[] vertices, int[] triangles, <#=b.type#> joinedVertices): this(vertices, triangles)
        {
            if(vertices is null)
                vertices = EmptyVertices;
            if(triangles is null)
                triangles = EmptyTriangles;
            _joinedVertices = joinedVertices;
        }
<# if (is3D[typeName]){ #>
/*
        public MeshFragment<#=fromDict[typeName]#> ToMeshFragment<#=fromDict[typeName]#>() =>
            new MeshFragment<#=fromDict[typeName]#>(this);

        internal MeshFragment<#=typeName#>(MeshFragment<#=fromDict[typeName]#> from)
        {
            this.vertices = from.vertices.ToArray<#=typeName#>();
            this.triangles = from.triangles;//(int[])triangles.Clone();
            this._joinedVertices = (<#=b.type#>)from._joinedVertices;

            Check();
        }
*/
<# } #>
    }
}
<#  manager.EndBlock();
    } #>
<# manager.Process(true); #>