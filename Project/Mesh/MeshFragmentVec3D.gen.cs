//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a _MeshFragment.tt
//     Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Collections.Pooled;
using CollectionLike;
using CollectionLike.Pooled;

namespace DoubleEngine
{
    public partial record MeshFragmentVec3D
    {
        internal static MeshFragmentVec3D CreateMeshFragmentAsIsWithoutArraysCopying(Vec3D[] vertices, int[] triangles)
            => new MeshFragmentVec3D(vertices, triangles);
        internal static MeshFragmentVec3D CreateMeshFragmentAsIsWithoutArraysCopying((Vec3D[] vertices, int[] triangles) tuple)
            => new MeshFragmentVec3D(tuple.vertices, tuple.triangles);
        public static MeshFragmentVec3D CreateMeshFragment(IMeshFragment<Vec3D> source) => 
            CreateMeshFragment(source.Vertices, source.Faces);
        public static MeshFragmentVec3D CreateMeshFragment(ReadOnlySpan<Vec3D> vertices, ReadOnlySpan<int> triangles)
            => new MeshFragmentVec3D(vertices.ToArray(), triangles.ToArray());

        public static MeshFragmentVec3D CreateMeshFragment(Vec3D[] vertices, int[] triangles)
            => new MeshFragmentVec3D((Vec3D[])vertices.Clone(), (int[])triangles.Clone());

        public static MeshFragmentVec3D CreateMeshFragment((List<Vec3D> vertices, List<int> triangles) tuple)
            => CreateMeshFragment(tuple.vertices, tuple.triangles);
        public static MeshFragmentVec3D CreateMeshFragment(List<Vec3D> vertices, List<int> triangles)
            => new MeshFragmentVec3D(vertices.ToArray(), triangles.ToArray());


        public static MeshFragmentVec3D CreateMeshFragment(List<Vec3D> vertices, List<(int v0i, int v1i, int v2i)> faces)
            => CreateMeshFragment(vertices.ToArray(), faces.ToArray()); 
        public static MeshFragmentVec3D CreateMeshFragment(Vec3D[] vertices, (int v0i, int v1i, int v2i)[] faces)
        {
            if (faces.Length == 0)
                return MeshFragmentVec3D.Empty;
            int[] triangles = new int[faces.Length * 3];
            for (var f = 0; f < faces.Length; f++)
            {
                triangles[(f * 3) + 0] = faces[f].v0i;
                triangles[(f * 3) + 1] = faces[f].v1i;
                triangles[(f * 3) + 2] = faces[f].v2i;
            }
            return new MeshFragmentVec3D((Vec3D[])vertices.Clone(), triangles);
        }
        public static MeshFragmentVec3D CreateMeshFragment(ReadOnlySpan<Vec3D> vertices, ReadOnlySpan<IndexedTri> faces)
        {
            if (faces.Length == 0)
                return MeshFragmentVec3D.Empty;
            int[] triangles = new int[faces.Length * 3];
            for (var f = 0; f < faces.Length; f++)
            {
                triangles[(f * 3) + 0] = faces[f].v0;
                triangles[(f * 3) + 1] = faces[f].v1;
                triangles[(f * 3) + 2] = faces[f].v2;
            }
            return new MeshFragmentVec3D((Vec3D[])vertices.ToArray(), triangles);
        }


        public MeshFragmentVec3D ScaledWithoutOrderInversion(Vec3D scale) => 
            new MeshFragmentVec3D(vertices.Scaled(scale), triangles);
        public MeshFragmentVec3D Scaled(Vec3D scale)
        {
            if (scale.x * scale.y * scale.z < 0)
                return new MeshFragmentVec3D(vertices.Scaled(scale), ReversedTriangles());
            //return new MeshFragment(vertices.Scaled(scale), triangles.Reversed().ToArray()); //Array reverse change triangles order to backwards
            return new MeshFragmentVec3D(vertices.Scaled(scale), triangles);
        }
        public MeshFragmentVec3D Rotated(QuaternionD rotation) => new MeshFragmentVec3D(vertices.Rotated(rotation), triangles);
        public MeshFragmentVec3D Translated(Vec3D translation) => new MeshFragmentVec3D(vertices.Translated(translation), triangles);
        public int[] ReversedTriangles()
        {
            int[] reversed = new int[triangles.Length];
            for (var i = 0; i < triangles.Length; i += 3)
                (reversed[i], reversed[i+1], reversed[i + 2]) = (triangles[i + 2], triangles[i + 1], triangles[i]);
            return reversed;
        }

        public MeshFragmentVec3D MakeFragmentWhereAllVerticesIs(Func<Vec3D, bool> VerticeSelector)
        {
            PooledList<int> selectedFaces = SelectFacesWhereAllVerticesIs(VerticeSelector);
            if (selectedFaces.Count == 0)
                return MeshFragmentVec3D.Empty;
            return CreateMeshFragmentAsIsWithoutArraysCopying(MeshUtil.RemoveUnusedVerticesAndFacesAndReturnNewArraysTriangles(Vertices,Faces,selectedFaces));;
        }

        public bool TryMakeNotEmptyFragmentWhereAllVerticesIs(Func<Vec3D, bool> VerticeSelector, out MeshFragmentVec3D fragment)
        {
            PooledList<int> selectedFaces = SelectFacesWhereAllVerticesIs(VerticeSelector);
            if (selectedFaces.Count == 0)
            {
                fragment = Empty;
                return false;
                //throw new ArgumentException("Selector has no triangles");
            }
            fragment = CreateMeshFragmentAsIsWithoutArraysCopying(
                MeshUtil.RemoveUnusedVerticesAndFacesAndReturnNewArraysTriangles(Vertices,Faces,selectedFaces));
            return true;
        }
        public PooledList<int> SelectFacesWhereAllVerticesIs(Func<Vec3D, bool> VerticeSelector)
        {
            PooledSet<int> selectedVertices = Vertices.SelectVertices(VerticeSelector);
            return Triangles.SelectFacesWhereAllVerticesInSet(selectedVertices);
        }

        public static void CheckTriangles(int[] triangles)
        {
            if (triangles.Length % 3 != 0)
                throw new ArgumentException("Every triangle must contain 3 vertices");
        }
        public static void CheckVerticeIndexes(int[] triangles, int vertexesLength)
        {
            foreach (int vertIndex in triangles)
                if (vertIndex < 0 || vertIndex >= vertexesLength)
                    throw new ArgumentException($"Vertice index {vertIndex} must address only vertices from 0 up to {vertexesLength}");
        }
        public void CheckNotNull()
        {
            if (vertices == null)
                throw new ArgumentException("MeshFragment vertices cannot be null");
            if (triangles == null)
                throw new ArgumentException("MeshFragment triangles cannot be null");
        }
        public MeshFragmentVec3D JoinedClosestVerticesIfNeeded(float epsilon = 0.000_01f) 
            {
            if (epsilon < 0)
                throw new ArgumentException("epsilon cannot be negative");
            //Debug.Log($"Mesh fragment Joined field is {_joinedVertices}");
            if (epsilon <= _joinedVertices)
            {
                //Debug.Log("Vertices already joined enough");
                return this;
            }
            for (int i=0; i<vertices.Length; i++)
                if (vertices.Count_CompareByEach(vertices[i], epsilon) > 1)
                    return JoinedClosestVertices(epsilon);
            /*
            for (int i=0; i<vertices.Length; i++)
                for(int j=0; j< vertices.Length; j++)
                {
                    if(i!=j && VectorUtil.CloseEnoughByEach(vertices[i],vertices[j],epsilon))
                        return JoinedClosestVertices(epsilon);
                }*/
            //Debug.Log("Found no need to Join vertices");
            return this;
            } 
        public MeshFragmentVec3D JoinedClosestVertices(float epsilon = 0.000_01f) //TODO test
        {
            if (vertices.Length == 0)
                return MeshFragmentVec3D.Empty;
            if (epsilon < 0)
                throw new ArgumentException("epsilon cannot be negative");

            int[] replaceVerticeIndex = new int[vertices.Length];
            replaceVerticeIndex[0] = 0;
            for (var i = 0; i < vertices.Length; i++)
                replaceVerticeIndex[i] = vertices.CloseWithLowerIndexOrSelf( i, epsilon);
            //replaceVerticeIndex[i] = vertices.ClosestOrLast(vertices[i], i, epsilon);
            /*
            int[] remapedTriangles = MeshUtil.RemapTriangles(triangles, replaceVerticeIndex);
            (int[] remapedVerticeIndexes, int[] newTriangles) = MeshUtil.CreatePartialMesh(remapedTriangles);
            Vec2D[] newVertices = vertices.AssembleIndices(remapedVerticeIndexes);//MeshUtil.RemapVertices(vertices, remapedVerticeIndexes);
            */
            using PooledList<IndexedTri> newFacesBuffer = Expendables.CreateList<IndexedTri>(Faces.Length);
            MeshUtil.AddRemappedNonDegenerateFacesToBuffer(replaceVerticeIndex.AsReadOnlySpan(), Faces, newFacesBuffer);
            using PooledArrayStruct<Vec3D> newVertices =
                MeshUtil.RemoveUnusedVerticesReturningPooledArrayAndReindexFaces_Span(newFacesBuffer.AsReadOnlySpan(), newFacesBuffer.AsSpan(), Vertices);

            return new MeshFragmentVec3D(newVertices.ToArray(), newFacesBuffer.AsReadOnlySpan().CastToInt_ReadOnlySpan().ToArray(), epsilon);
        }

        private void Check()
        {
            CheckNotNull();
            CheckTriangles(triangles);
            CheckVerticeIndexes(triangles, vertices.Length);
        }
    }
}
