<#@ template language="C#" hostspecific="True"#>
<#@ output extension=".gen.cs" #>
<#@ include file="$(ProjectDir)\_Include\_0_AssemplyImports.ttinclude" #>

<#@ import namespace="System.IO" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>

<#@ include file="$(ProjectDir)\_Include\_1_ManagerMultipleOutputHelper.ttinclude"#>
<#@ include file="$(ProjectDir)\_Include\_2_GlobalTTInclude.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_4_typeDeclaration.ttinclude" #>

<#@ include file="$(ProjectDir)\_Include\_6_Vec3D_typeInitialization.ttinclude" #>
<# 
// include file="$(ProjectDir)\_Include\_6_Vector3Unity_typeInitialization.ttinclude" 
#>
<# FileInfo t4FileInfo = new FileInfo( this.Host.TemplateFile );#>
//// this file was generated as byproduct of generating *.gen.cs files from master template: <#=t4FileInfo.Name#>

<# var manager = Manager.Create(Host, GenerationEnvironment); #>
<# 

Dictionary<string,string> quatDict = new Dictionary<string,string>();
quatDict["Vec3D"] = "QuaternionD";
quatDict["Vector3"] = "Quaternion";

Dictionary<string,string> matrixDict = new Dictionary<string,string>();
matrixDict["Vec3D"] = "MatrixD4x4";
matrixDict["Vector3"] = "Matrix4x4";

for(var k = 0; k<availableTypes.Count; k++)
    {
    UnfoldTypeDescription(availableTypes[k]);
    string filename = $"MeshBuilder{typeName}.gen.cs";
    WriteLine($"//// Generating: {filename}");
    manager.StartNewFile(filename); #>
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a <#=t4FileInfo.Name#>
//     Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using Collections.Pooled;
using System.Linq;
using CollectionLike.Pooled;

namespace <#=globalNamespaceName#>
{
    public class MeshBuilder<#=typeName#>: IDisposable, IMeshBuilder<MeshFragment<#=typeName#>, <#=typeName#>, <#=quatDict[typeName]#>>
    {
        private PooledList<<#=typeName#>> _vertexes;
        private PooledList<int> _triangles;

        private HashSet<int> _onlyUseFaces;
        private HashSet<int> _facesToRemove;

        <#=typeName#>? scale = null; 
        <#=quatDict[typeName]#>? rotation = null;
        <#=typeName#>? translation = null;

        private int MeshFacesCount => _triangles.Count / 3;

        public MeshBuilder<#=typeName#>()
        {
            _vertexes = new PooledList<<#=typeName#>>();
            _triangles = new PooledList<int>();
        }
        public MeshBuilder<#=typeName#>(MeshFragment<#=typeName#> initial)
        {
            _vertexes = new PooledList<<#=typeName#>>(initial.vertices);
            _triangles = new PooledList<int>(initial.triangles);
        }
        public MeshBuilder<#=typeName#>(<#=typeName#>[] vertexes, int[] triangles)
        {
            _vertexes = new PooledList<<#=typeName#>>(vertexes);
            _triangles = new PooledList<int>(triangles);
            MeshFragment<#=typeName#>.CheckTriangles(triangles);
            MeshFragment<#=typeName#>.CheckVerticeIndexes(triangles, vertexes.Length);
        }
        public void AddMeshFragment(MeshFragment<#=typeName#> fragment) //TODO TEST
        {
            int newStartAt = _vertexes.Count;
            _triangles.AddRange(fragment.triangles.Select(x=>x+newStartAt));
            _vertexes.AddRange(fragment.vertices);
        }
        public void AddMeshFragment(MeshFragment<#=typeName#> fragment, <#=typeName#> fragmentTranslation) //TODO TEST
        {
            int newStartAt = _vertexes.Count;
            _triangles.AddRange(fragment.triangles.Select(x=>x+newStartAt));
            for(int i=0;i<fragment.vertices.Length;++i)
                _vertexes.Add(fragment.vertices[i]+fragmentTranslation);
        }
<# if (typeName!="Vector3"){ #>
        public void AddMeshFragment(MeshFragment<#=typeName#> fragment, <#=quatDict[typeName]#> rotation, <#=typeName#> translation) //TODO TEST
        {
            int newStartAt = _vertexes.Count;
            _triangles.AddRange(fragment.triangles.Select(x=>x+newStartAt));
            MatrixD4x4 m = MatrixD4x4.FromOperationRotateThenTranslate(rotation, translation);
            for(int i=0;i<fragment.vertices.Length;++i)
                _vertexes.Add(m.MultiplyPoint3x4(fragment.vertices[i]));//rotation.Rotate(fragment.vertices[i])+translation);
        }
        public void AddMeshFragment(MeshFragment<#=typeName#> fragment,<#=typeName#> scale, <#=quatDict[typeName]#> rotation, <#=typeName#> translation) //TODO TEST
        {
            int newStartAt = _vertexes.Count;
            if (scale.x * scale.y * scale.z < 0)
                _triangles.AddRange(fragment.triangles.Select(x => x + newStartAt).Reverse());
            else
                _triangles.AddRange(fragment.triangles.Select(x => x + newStartAt));
            var m = MatrixD4x4.FromOperationScaleThenRotateThenTranslate(scale, rotation, translation);
            for(int i=0;i<fragment.vertices.Length;++i)
                _vertexes.Add(m.MultiplyPoint3x4(fragment.vertices[i]));//rotation.Rotate(fragment.vertices[i].Scaled(scale))+translation);
        }
<# } else {#>
        public void AddMeshFragment(MeshFragment<#=typeName#> fragment, <#=quatDict[typeName]#> rotation, <#=typeName#> fragmentTranslation) =>
            throw new NotImplementedException();
        public void AddMeshFragment(MeshFragment<#=typeName#> fragment,<#=typeName#> scale, <#=quatDict[typeName]#> rotation, <#=typeName#> fragmentTranslation) =>
            throw new NotImplementedException();
<# } #>
        public void Dispose()
        {
            Clear();
            _vertexes.Dispose();
            _triangles.Dispose();
        }
        public void Clear()
        {
            _vertexes.Clear();
            _triangles.Clear();
            _onlyUseFaces = null;
            _facesToRemove = null;
            scale = null;
            rotation = null;
            translation = null;
        }
        public void AddTranslation(<#=typeName#> t) => translation = translation.Translated(t);
        public void AddRotation(<#=quatDict[typeName]#> r) => rotation = rotation.Rotated(r);
        public void AddScale(<#=typeName#> v) => scale = scale.Scaled(v);
        public MeshFragment<#=typeName#> BuildFragment()
        {
            Build_5_RemoveUnusedFacesAndVertices();
            Build_11_ApplyScaleRotationTranslation();
            return MeshFragment<#=typeName#>.CreateMeshFragment(_vertexes.AsReadOnlySpan(), _triangles.AsReadOnlySpan());
        }
        public void RemoveFaces(int[] faces)
        {
            Init_facesToRemove();
            foreach (var face in faces)
                _facesToRemove.Add(face);
        }
        public void OnlyUseFaces(int[] faces)
        {
            _onlyUseFaces = new HashSet<int>(faces);
        }

        private void Build_5_RemoveUnusedFacesAndVertices()
        {
            IEnumerable<int> useFaces = null;

            if(_facesToRemove!=null && _onlyUseFaces!=null)
                useFaces = _onlyUseFaces.Except(_facesToRemove);
            else if(_facesToRemove!=null)
            {
                useFaces = Enumerable.Range(0, MeshFacesCount).Except(_facesToRemove);
            }
            else if (_onlyUseFaces != null)
                useFaces = _onlyUseFaces;

            _facesToRemove = null;
            _onlyUseFaces = null;
            RemoveUnusedFacesAndVertices(useFaces);
        }
        [Obsolete("not tested")]
        private void RemoveUnusedFacesAndVertices(IEnumerable<int> newMeshFaceIdexes = null)
        {
           (var newVertexes, var newTriangles) = MeshUtil.RemoveUnusedVerticesAndFacesAndReturnNewArraysTriangles(
           _vertexes.AsReadOnlySpan(),_triangles.AsReadOnlySpan().CastToIndexedTri_ReadOnlySpan(),newMeshFaceIdexes);
            _vertexes.Clear();
            _vertexes.AddRange(newVertexes);
            _triangles.Clear();
            _triangles.AddRange(newTriangles);
        
        }
        private void Build_11_ApplyScaleRotationTranslation()
        {
            if (scale == null && rotation == null && translation == null)
                return;

            <#=matrixDict[typeName]#> m = <#=matrixDict[typeName]#>.identity;
            //order of matrix multiplication important
            if (translation != null)
                m = m * <#=matrixDict[typeName]#>.Translate(translation.Value);

            if (rotation != null)
                m = m * <#=matrixDict[typeName]#>.Rotate(rotation.Value);

            if (scale != null)
            {
                <#=typeName#> _scale = scale.Value;
                m = m * <#=matrixDict[typeName]#>.Scale(_scale);
                if (_scale.x * _scale.y * _scale.z < 0)
                    ReverseTriangles();
            }
            //if (m.m00 * m.m11 * m.m22 < 0) //do not use matrix to find inversion because it somehow gives falsepositives depending on rotation Quaternion
            //    ReverseTriangles();

            for (var i = 0; i<_vertexes.Count; i++)
                _vertexes[i] = m.MultiplyPoint3x4(_vertexes[i]);

        }
        private void ReverseTriangles()
        {
            for (var i = 0; i < _triangles.Count; i += 3)
                (_triangles[i], _triangles[i + 2]) = (_triangles[i + 2], _triangles[i]);
        }
        private void Init_facesToRemove()
        {
            if (_facesToRemove == null)
                _facesToRemove = new HashSet<int>();
        }
    }
}
<#  manager.EndBlock();
    } #>
<# manager.Process(true); #>