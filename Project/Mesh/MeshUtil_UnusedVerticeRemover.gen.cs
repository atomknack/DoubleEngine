//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

using System;
using System.Threading;
using System.Collections.Generic;
using Collections.Pooled;
using CollectionLike.Pooled;

namespace DoubleEngine
{
    public static partial class MeshUtil
    {
        private ref struct UnusedVerticeRemover
        {
            private static ThreadLocal<PooledArrayStruct<int>> s_newVertexIndex =
                new ThreadLocal<PooledArrayStruct<int>>(() => new PooledArrayStruct<int>());

            internal Span<int> newVerticesIndex;
            internal int newVerticesCount;
            internal const int NOINDEX = -1;


            //[Obsolete("URGENT! need testing")]
            public static PooledArrayStruct<TVertice> RemoveUnusedVerticesReturningPooledArrayAndReindexFaces_Span<TVertice>(ReadOnlySpan<IndexedTri> faces, Span<IndexedTri> newFaces, ReadOnlySpan<TVertice> vertices) where TVertice : struct
            {
                var remover = new UnusedVerticeRemover(vertices.Length);
                remover.RemapFaces_Span(faces, newFaces);
                var result = Expendables.CreateArray<TVertice>(remover.newVerticesCount);
                remover.RemapVertices_Span(vertices, result.AsSpan());
                return result;
            }

            private void RemapFaces_Span(ReadOnlySpan<IndexedTri> oldFaces, Span<IndexedTri> newFaces)
            {
                for (int i = 0; i < oldFaces.Length; ++i)
                {
                    newFaces[i] = new IndexedTri(
                        AddVerticeIndexAndReturnNewVerticeIndex(oldFaces[i].v0),
                        AddVerticeIndexAndReturnNewVerticeIndex(oldFaces[i].v1),
                        AddVerticeIndexAndReturnNewVerticeIndex(oldFaces[i].v2));
                }
            }
            //[Obsolete("need testing")]
            private void RemapVertices_Span<TVertice>(ReadOnlySpan<TVertice> oldVertices, Span<TVertice> newVertices) where TVertice : struct
            {
                for (int i = 0; i < newVerticesIndex.Length; ++i)
                {
                    int newIndex = newVerticesIndex[i];
                    if (newIndex != NOINDEX)
                        newVertices[newIndex] = oldVertices[i];
                }
            }

            //[Obsolete("URGENT! need testing")]
            public static PooledArrayStruct<TVertice> RemoveUnusedVerticesReturningPooledArrayAndReindexFaces_IList<TVertice>(IReadOnlyList<IndexedTri> faces, IList<IndexedTri> newFaces, IReadOnlyList<TVertice> vertices) where TVertice : struct
            {
                var remover = new UnusedVerticeRemover(vertices.Count);
                remover.RemapFaces_IList(faces, newFaces);
                var result = Expendables.CreateArray<TVertice>(remover.newVerticesCount);
                remover.RemapVertices_IList(vertices, result.AsSpan());
                return result;
            }

            private void RemapFaces_IList(IReadOnlyList<IndexedTri> oldFaces, IList<IndexedTri> newFaces)
            {
                for (int i = 0; i < oldFaces.Count; ++i)
                {
                    newFaces[i] = new IndexedTri(
                        AddVerticeIndexAndReturnNewVerticeIndex(oldFaces[i].v0),
                        AddVerticeIndexAndReturnNewVerticeIndex(oldFaces[i].v1),
                        AddVerticeIndexAndReturnNewVerticeIndex(oldFaces[i].v2));
                }
            }
            //[Obsolete("need testing")]
            private void RemapVertices_IList<TVertice>(IReadOnlyList<TVertice> oldVertices, Span<TVertice> newVertices) where TVertice : struct
            {
                for (int i = 0; i < newVerticesIndex.Length; ++i)
                {
                    int newIndex = newVerticesIndex[i];
                    if (newIndex != NOINDEX)
                        newVertices[newIndex] = oldVertices[i];
                }
            }
            private int AddVerticeIndexAndReturnNewVerticeIndex(int verticeIndex)
            {
                int newIndex = newVerticesIndex[verticeIndex];
                if (newIndex != NOINDEX)
                    return newIndex;
                newIndex = newVerticesCount;
                ++newVerticesCount;
                newVerticesIndex[verticeIndex] = newIndex;
                return newIndex;
            }
            private UnusedVerticeRemover(int oldVerticesLength)
            {
                s_newVertexIndex.Value = s_newVertexIndex.Value.InvalidateIfNeededAndReturnResized(oldVerticesLength);
                newVerticesIndex = s_newVertexIndex.Value.AsSpan();
                newVerticesIndex.Fill(NOINDEX);
                newVerticesCount = 0;
            }

        }
    }
}