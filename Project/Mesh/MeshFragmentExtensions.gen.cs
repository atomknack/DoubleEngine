


//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a MeshFragmentExtensions.tt
//     Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Text;

namespace DoubleEngine
{
    public static class MeshFragmentExtensions
    {
/*
        [Obsolete("Replace all non critical places with interface version")]
        public static IEnumerable<TriVec3D> Tris(this MeshFragmentVec3D m) //need testing
        {
        for (int i=0; i<m.triangles.Length; i+=3)
            yield return new TriVec3D(m.vertices[m.triangles[i]], m.vertices[m.triangles[i+1]], m.vertices[m.triangles[i+2]]);
        }
*/
        //[Obsolete("Not tested")]
        public static TriVec3D[] Tris(this IMeshFragment<Vec3D> mesh) //need testing
        {
            ReadOnlySpan<IndexedTri> faces = mesh.Faces;
            ReadOnlySpan<Vec3D> vertices = mesh.Vertices;
            TriVec3D[] result = new TriVec3D[faces.Length];
            for (int i=0; i<faces.Length; ++i)
            {
                result[i] = new TriVec3D(vertices[faces[i].v0], vertices[faces[i].v1], vertices[faces[i].v2]);
            }
            return result;
        }
        /*
        [Obsolete("Replace all non critical places with interface version")]
        public static bool ContainsEqualishTriangle(this MeshFragmentVec3D mesh, TriVec3D tri, double epsilon = 0.000001d)
        {
            int[] tris = mesh.triangles;
            for (int i = 0; i < tris.Length; i += 3)
            {
                TriVec3D meshTri = new TriVec3D(mesh.vertices[tris[i]], mesh.vertices[tris[i + 1]], mesh.vertices[tris[i + 2]]);
                if (tri.VerticesEqual_Manhattan(meshTri, epsilon))
                    return true;
                if (tri.VerticesEqual_Manhattan(meshTri.ShiftOnce(), epsilon))
                    return true;
                if (tri.VerticesEqual_Manhattan(meshTri.ShiftTwice(), epsilon))
                    return true;
            }
            return false;
        }*/
        public static bool ContainsEqualishTriangle(this IMeshFragment<Vec3D> mesh, TriVec3D tri, double epsilon = 0.000001d)
        {
            ReadOnlySpan<int> tris = mesh.Triangles;
            ReadOnlySpan<Vec3D> vertices = mesh.Vertices;
            for (int i = 0; i < tris.Length; i += 3)
            {
                TriVec3D meshTri = new TriVec3D(vertices[tris[i]], vertices[tris[i + 1]], vertices[tris[i + 2]]);
                if (tri.VerticesEqual_Manhattan(meshTri, epsilon))
                    return true;
                if (tri.VerticesEqual_Manhattan(meshTri.ShiftOnce(), epsilon))
                    return true;
                if (tri.VerticesEqual_Manhattan(meshTri.ShiftTwice(), epsilon))
                    return true;
            }
            return false;
        }
    }
}
