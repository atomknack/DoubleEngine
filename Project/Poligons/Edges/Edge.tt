<#@ template language="C#" hostspecific="True"#>
<#@ output extension=".gen.cs" #>
<#@ include file="$(ProjectDir)\_Include\_0_AssemplyImports.ttinclude" #>

<#@ import namespace="System.IO" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>

<#@ include file="$(ProjectDir)\_Include\_1_ManagerMultipleOutputHelper.ttinclude"#>
<#@ include file="$(ProjectDir)\_Include\_2_GlobalTTInclude.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_4_typeDeclaration.ttinclude" #>

<#@ include file="$(ProjectDir)\_Include\_6_Vec2D_typeInitialization.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_6_Vec3D_typeInitialization.ttinclude" #>
<# FileInfo t4FileInfo = new FileInfo( this.Host.TemplateFile );#>
//// this file was generated as byproduct of generating *.gen.cs files from master template: <#=t4FileInfo.Name#>

<# var manager = Manager.Create(Host, GenerationEnvironment); #>
<# 

Dictionary<string,string> quatDict = new Dictionary<string,string>();
quatDict["Vec3D"] = "QuaternionD";
quatDict["Vector3"] = "Quaternion";

Dictionary<string,string> edgeCreationEpsilon = new Dictionary<string,string>();
edgeCreationEpsilon["Vec2D"] = "1E-09d";
edgeCreationEpsilon["Vec3D"] = "1E-09d";
edgeCreationEpsilon["Vector2"] = "1E-06f";
edgeCreationEpsilon["Vector3"] = "1E-06f";

string projectionMinEpsilon = "-0.0000001";
string projectionMaxEpsilon = "1.0000001";
string distanceSqrEpsilon = "1E-07";

for(var k = 0; k<availableTypes.Count; k++)
    {
    UnfoldTypeDescription(availableTypes[k]);
    string filename = $"Edge{typeName}.gen.cs";
    WriteLine($"//// Generating: {filename}");
    manager.StartNewFile(filename); #>
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a <#=t4FileInfo.Name#>
//     Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

using System;

namespace DoubleEngine
{
    public readonly partial struct Edge<#=typeName#>
    {
        public readonly <#=typeName#> start;
        public readonly <#=typeName#> end;

		public readonly <#=typeName#> segmentVector;
		public readonly <#=b.type#> segmentSqrMagnitude;

		public readonly override string ToString() => $"Edge<#=typeName#>({start.ToString()}, {end.ToString()})";

        public Edge<#=typeName#>(<#=typeName#> start, <#=typeName#> end)
        {
            this.start = start;
            this.end = end;
			segmentVector = end - start;
			segmentSqrMagnitude = segmentVector.MagnitudeSqr();
			if (segmentSqrMagnitude < <#=edgeCreationEpsilon[typeName]#>)
				throw new ArgumentException("Line segment should not be a point");
		}

		public static bool SameDirection(in Edge<#=typeName#> a, in Edge<#=typeName#> b) => <#=typeName#>.Dot(a.segmentVector, b.segmentVector)>0;

		public readonly bool PointBelongsToEdge(<#=typeName#> point) //Need testing
		{
			<#=b.type#> projectionPosition = PositionOnEdge(point);
			if (projectionPosition < <#=projectionMinEpsilon#><#=b.valueEnding#> || projectionPosition > <#=projectionMaxEpsilon#><#=b.valueEnding#>)
				return false; //Point is outside of line segment, it may or may not belong to some other part of line
			<#=typeName#> projectedPoint = GetPoint(projectionPosition);
			if (point.DistanceSqr(projectedPoint) >= <#=distanceSqrEpsilon#><#=b.valueEnding#>)
				return false; //Point is not belongs to any part of line
			return true;
		}
		[Obsolete("Epsilons too low, need adjusting")]
		public static bool PointBelongsToEdge(<#=typeName#> lineStart, <#=typeName#> lineEnd, <#=typeName#> point) //Need testing
		{
			<#=typeName#> lineVector = lineEnd - lineStart;
			<#=typeName#> pointInLineStartCoords = point - lineStart;
			<#=b.type#> projectionPosition = <#=typeName#>.Dot(pointInLineStartCoords, lineVector) / lineVector.MagnitudeSqr();
			if (projectionPosition < <#=projectionMinEpsilon#><#=b.valueEnding#> || projectionPosition > <#=projectionMaxEpsilon#><#=b.valueEnding#>)
				return false; //Point is outside of line segment, it may or may not belong to some other part of line
			<#=typeName#> projectedPoint = lineStart + (lineVector * projectionPosition);
			if (point.DistanceSqr(projectedPoint) >= <#=distanceSqrEpsilon#><#=b.valueEnding#>)
				return false; //Point is not belongs to any part of line
			return true;
		}
		public readonly <#=typeName#> ProjectPointOnEdge(<#=typeName#> Point) =>
			GetPoint( PositionOnEdge(Point) );
		public static <#=typeName#> ProjectPointOnEdge(<#=typeName#> lineStart, <#=typeName#> lineEnd, <#=typeName#> point) //Need testing
		{
			<#=typeName#> lineVector = lineEnd - lineStart;
			<#=typeName#> pointInLineStartCoords = point - lineStart;
			<#=b.type#> projectionPosition = <#=typeName#>.Dot(pointInLineStartCoords, lineVector) / lineVector.MagnitudeSqr();
			return lineStart + (lineVector * projectionPosition);
		}

		public readonly <#=typeName#> GetPoint(<#=b.type#> position) =>
			start + (segmentVector * position);
		public static <#=typeName#> GetPoint(<#=typeName#> edgeStart, <#=typeName#> edgeEnd, <#=b.type#> position) =>
			edgeStart + ((edgeEnd - edgeStart) * position);
		public readonly <#=b.type#> PositionOnEdge(<#=typeName#> Point) =>
			<#=typeName#>.Dot(Point - start, segmentVector) / segmentSqrMagnitude;

	}
}
//
<#  manager.EndBlock();
    } #>
<# manager.Process(true); #>