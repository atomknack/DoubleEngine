//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a Tri.tt
//     Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;

namespace DoubleEngine
{
    public readonly partial struct TriVec3D
    {        
        public readonly Vec3D v0;
        public readonly Vec3D v1;
        public readonly Vec3D v2;

        public TriVec3D(Vec3D v0, Vec3D v1, Vec3D v2)
        {
            this.v0 = v0;
            this.v1 = v1;
            this.v2 = v2;
        }
        public TriVec3D(ReadOnlySpan<Vec3D> vertices, IndexedTri iTri)
        {
            this.v0 = vertices[iTri.v0];
            this.v1 = vertices[iTri.v1];
            this.v2 = vertices[iTri.v2];
        }

        public void Deconstruct(out Vec3D v0, out Vec3D v1, out Vec3D v2)
        {
            v0 = this.v0;
            v1 = this.v1;
            v2 = this.v2;
        }
        public override string ToString()
        {
            return $"{v0}, {v1}, {v2}";
        }

        public readonly bool VerticesEqual_Manhattan(TriVec3D other, double epsilon = 0.000001d) //TODO: need testing
        {
            if( (v0.DistanceManhattan(other.v0) <= epsilon) && (v1.DistanceManhattan(other.v1) <= epsilon) && (v2.DistanceManhattan(other.v2) <= epsilon) )
                return true;
            return false;
        }
        public readonly TriVec3D ShiftOnce() => new TriVec3D(v1, v2, v0); //TODO: need testing
        public readonly TriVec3D ShiftTwice() => new TriVec3D(v2, v0, v1); //TODO: need testing

        public static double DotBetweenSides(Vec3D sideAvector, Vec3D center, Vec3D sideBvector)=>
            Vec3D.Dot((sideAvector-center).Normalized(), (sideBvector-center).Normalized());

        /*
        private const double THIRD = 1d / 3d;
        public static (Vec3D center, double maxDistanceSqr) CalcSqrSphere(Vec3D v0, Vec3D v1, Vec3D v2)
        {
            var center = (v0+v1+v2)*THIRD;
            var maxDistanceSqr = MathU.Max(center.DistanceSqr(v0), center.DistanceSqr(v1));
            maxDistanceSqr = MathU.Max(maxDistanceSqr, center.DistanceSqr(v2));
            return (center, maxDistanceSqr);
        }
        */
    }

}

