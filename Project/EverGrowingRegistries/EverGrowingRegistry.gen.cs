//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;


namespace DoubleEngine
{
    public sealed class EverGrowingRegistry<T>: IRegistry<T>
        where T : IEquatable<T>    {
        public static EverGrowingRegistry<T> Shared { get { return GetInstance(); } }
        public static EverGrowingRegistry<T> Create(int startingCapacity = 100) => new EverGrowingRegistry< T>(startingCapacity);

        private int _registeredCount;
        private T[] _currentArray;
        private ConcurrentDictionary<T, int> _allElements;
        private static EverGrowingRegistry<T> _instance = null;
        private static object _lock = new object();
        
        private static EverGrowingRegistry<T> GetInstance()
        {
            if (_instance != null)
                return _instance;
            lock (_lock)
            {
                if (_instance == null)
                    _instance = new EverGrowingRegistry<T>();
                return _instance;
            }
        }
        public T[] AssembleIndices(ReadOnlySpan<RegistryIndex> indexes)
        {
        T[] items = new T[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public T[] AssembleIndices(RegistryIndex[] indexes)
        {
        T[] items = new T[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public T[] AssembleIndices(List<RegistryIndex> indexes)
        {
        T[] items = new T[indexes.Count];
        for(int i=0; i<indexes.Count; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public T GetItem(RegistryIndex index) => _currentArray[index.Value];
        public T this[RegistryIndex index]{ get=> _currentArray[index.Value]; }
        public ReadOnlySpan<T> Snapshot() => new ReadOnlySpan<T>(_currentArray, 0, _registeredCount);
        public RegistryIndex GetOrAdd(T item)
        {
            if (_allElements.TryGetValue(item, out int found))
                return new RegistryIndex(found);
            lock (_lock) //this implementation is slowish but should be bulletproof
            { 
                if (_allElements.TryGetValue(item, out int insideLock))
                    return new RegistryIndex(insideLock);
                int newElementIndex = AddToArrayInsideLock(item);
                if (_allElements.TryAdd(item, newElementIndex))
                    return new RegistryIndex(newElementIndex);
                throw new Exception("Cannot add element to ConcurrentDictionary inside lock, this should newer happen, program should be terminated");
            }

            int AddToArrayInsideLock(T item)
            {
                int newElementIndex = _registeredCount;
                if (newElementIndex >= _currentArray.Length)
                {
                    int newArraysSize = newElementIndex * 2;
                    T[] newArray = new T[newArraysSize];
                    Array.Copy(_currentArray, newArray, _currentArray.Length);
                    _currentArray = newArray;
                }
                _currentArray[newElementIndex] = item;
                _registeredCount++;
                return newElementIndex;
            }
        }
        protected EverGrowingRegistry(int startingCapacity = 100)
        {
            _registeredCount = 0;
            _currentArray = new T[startingCapacity];
            _allElements = new();

        }
    }
}

