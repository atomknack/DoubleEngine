//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using CollectionLike.Comparers.SetsWithCustomComparer;

namespace DoubleEngine
{
    public sealed class EverGrowingVec3DVec3F: IRegistry<Vec3D>
    {
        public static EverGrowingVec3DVec3F Shared { get { return GetInstance(); } }
        public static EverGrowingVec3DVec3F Create(int startingCapacity = 100) => new EverGrowingVec3DVec3F(startingCapacity);

        private int _registeredCount;
        private Vec3D[] _currentArray;
        private ConcurrentDictionary<Vec3D, int> _allElements;
        private static EverGrowingVec3DVec3F _instance = null;
        private static object _lock = new object();
        public const double EPSILON = Vec3DComparer_2em5.EPSILON;
        private Vec3F[] _convertedArray;
        public Vec3F GetItemVec3F(RegistryIndex index)=> _convertedArray[index.Value];
        public ReadOnlySpan<Vec3F> SnapshotConverted() => new ReadOnlySpan<Vec3F>(_convertedArray, 0, _registeredCount);
        //public int GetOrAdd(Vec3F item) => GetOrAdd(item.ConvertTo(out _));
        public Vec3F[] AssembleIndicesConverted(ReadOnlySpan<RegistryIndex> indexes)
        {
        Vec3F[] items = new Vec3F[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _convertedArray[indexes[i].Value];
        return items;
        }
        public Vec3F[] AssembleIndicesConverted(RegistryIndex[] indexes)
        {
        Vec3F[] items = new Vec3F[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _convertedArray[indexes[i].Value];
        return items;
        }
        public Vec3F[] AssembleIndicesConverted(List<RegistryIndex> indexes)
        {
        Vec3F[] items = new Vec3F[indexes.Count];
        for(int i=0; i<indexes.Count; i++)
            items[i] = _convertedArray[indexes[i].Value];
        return items;
        }
        public Vec3F[] AssembleIndicesConverted(IReadOnlyList<RegistryIndex> indexes)
        {
        Vec3F[] items = new Vec3F[indexes.Count];
        for(int i=0; i<indexes.Count; i++)
            items[i] = _convertedArray[indexes[i].Value];
        return items;
        }
        private static EverGrowingVec3DVec3F GetInstance()
        {
            if (_instance != null)
                return _instance;
            lock (_lock)
            {
                if (_instance == null)
                    _instance = new EverGrowingVec3DVec3F();
                return _instance;
            }
        }
        public Vec3D[] AssembleIndices(ReadOnlySpan<RegistryIndex> indexes)
        {
        Vec3D[] items = new Vec3D[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public Vec3D[] AssembleIndices(RegistryIndex[] indexes)
        {
        Vec3D[] items = new Vec3D[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public Vec3D[] AssembleIndices(List<RegistryIndex> indexes)
        {
        Vec3D[] items = new Vec3D[indexes.Count];
        for(int i=0; i<indexes.Count; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public Vec3D GetItem(RegistryIndex index) => _currentArray[index.Value];
        public Vec3D this[RegistryIndex index]{ get=> _currentArray[index.Value]; }
        public ReadOnlySpan<Vec3D> Snapshot() => new ReadOnlySpan<Vec3D>(_currentArray, 0, _registeredCount);
        public RegistryIndex GetOrAdd(Vec3D item)
        {
            if (_allElements.TryGetValue(item, out int found))
                return new RegistryIndex(found);
            lock (_lock) //this implementation is slowish but should be bulletproof
            { 
                if (_allElements.TryGetValue(item, out int insideLock))
                    return new RegistryIndex(insideLock);
                int newElementIndex = AddToArrayInsideLock(item);
                if (_allElements.TryAdd(item, newElementIndex))
                    return new RegistryIndex(newElementIndex);
                throw new Exception("Cannot add element to ConcurrentDictionary inside lock, this should newer happen, program should be terminated");
            }

            int AddToArrayInsideLock(Vec3D item)
            {
                int newElementIndex = _registeredCount;
                if (newElementIndex >= _currentArray.Length)
                {
                    int newArraysSize = newElementIndex * 2;
                    Vec3D[] newArray = new Vec3D[newArraysSize];
                    Array.Copy(_currentArray, newArray, _currentArray.Length);
                    _currentArray = newArray;
                    Vec3F[] newConvertedArray = new Vec3F[newArraysSize];
                    Array.Copy(_convertedArray, newConvertedArray, _convertedArray.Length);
                    _convertedArray = newConvertedArray;
                }
                _currentArray[newElementIndex] = item;
                _convertedArray[newElementIndex] = item.ConvertTo(out Vec3F _);
                _registeredCount++;
                return newElementIndex;
            }
        }
        protected EverGrowingVec3DVec3F(int startingCapacity = 100)
        {
            _registeredCount = 0;
            _currentArray = new Vec3D[startingCapacity];
            _allElements = new(Vec3DComparer_2em5.ComparerInstance);
            _convertedArray = new Vec3F[startingCapacity];
        }
    }
}
