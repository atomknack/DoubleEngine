//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

using System;
using System.Buffers;
using System.Collections.Generic;
using Collections.Pooled;
using CollectionLike.Comparers.SetsWithCustomComparer;
using CollectionLike.Pooled;
using System.Text;

namespace DoubleEngine
{
    public sealed class LinearRegistyVec2D: IRegistry<Vec2D>, IDisposable
    {
        public static LinearRegistyVec2D Create(int startingCapacity = 100) => new LinearRegistyVec2D(startingCapacity);

        private int _registeredCount;
        private Vec2D[] _currentArray;

        private ArrayPool<Vec2D> _pool;
        private bool _disposed;

        internal static bool ItemsEqual(Vec2D a, Vec2D b) => a.CloseByEach(b, Vec2DComparer_2em5.EPSILON);

        public Vec2D[] AssembleIndices(ReadOnlySpan<RegistryIndex> indexes)
        {
        Vec2D[] items = new Vec2D[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public PooledList<Vec2D> PoolListAssembleIndices(ReadOnlySpan<RegistryIndex> indexes)
        {
        PooledList<Vec2D> items = new PooledList<Vec2D>(indexes.Length, ClearMode.Never, true);
        for(int i=0; i<indexes.Length; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public Vec2D[] AssembleIndices(RegistryIndex[] indexes)
        {
        Vec2D[] items = new Vec2D[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public PooledList<Vec2D> PoolListAssembleIndices(RegistryIndex[] indexes)
        {
        PooledList<Vec2D> items = new PooledList<Vec2D>(indexes.Length, ClearMode.Never, true);
        for(int i=0; i<indexes.Length; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public Vec2D[] AssembleIndices(List<RegistryIndex> indexes)
        {
        Vec2D[] items = new Vec2D[indexes.Count];
        for(int i=0; i<indexes.Count; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public PooledList<Vec2D> PoolListAssembleIndices(List<RegistryIndex> indexes)
        {
        PooledList<Vec2D> items = new PooledList<Vec2D>(indexes.Count, ClearMode.Never, true);
        for(int i=0; i<indexes.Count; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public Vec2D[] AssembleIndices(IReadOnlyList<RegistryIndex> indexes)
        {
        Vec2D[] items = new Vec2D[indexes.Count];
        for(int i=0; i<indexes.Count; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public PooledList<Vec2D> PoolListAssembleIndices(IReadOnlyList<RegistryIndex> indexes)
        {
        PooledList<Vec2D> items = new PooledList<Vec2D>(indexes.Count, ClearMode.Never, true);
        for(int i=0; i<indexes.Count; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public Vec2D GetItem(RegistryIndex index) => _currentArray[index.Value];
        public Vec2D this[RegistryIndex index]{ get=> _currentArray[index.Value]; }
        public ReadOnlySpan<Vec2D> Snapshot() => new ReadOnlySpan<Vec2D>(_currentArray, 0, _registeredCount);

        private bool TryGetIndex(Vec2D item, out RegistryIndex index)
        {
            for(int i = 0; i< _registeredCount; ++i)
                if (ItemsEqual(item, _currentArray[i]))
                {
                    index = new RegistryIndex(i);
                    return true;
                }
            index = new RegistryIndex(-1);
            return false;
        }

        public RegistryIndex GetOrAdd(Vec2D item)
        {
            if (TryGetIndex(item, out RegistryIndex foundIndex))
                return foundIndex;

                int newElementIndex = AddToArray(item);
                return new RegistryIndex(newElementIndex);

            int AddToArray(Vec2D item)
            {
                int newElementIndex = _registeredCount;
                if (newElementIndex >= _currentArray.Length)
                {
                    int newArraysSize = newElementIndex * 2;
                    Vec2D[] newArray = _pool.RentOrGetEmpty(newArraysSize);
                    Array.Copy(_currentArray, newArray, _currentArray.Length);
                    Vec2D[] oldArray = _currentArray;
                    _currentArray = newArray;
                    _pool.ReleaseAndSetAsEmpty(ref oldArray);
                }
                _currentArray[newElementIndex] = item;

                _registeredCount++;
                return newElementIndex;
            }
        }
        protected LinearRegistyVec2D(int startingCapacity = 100)
        {
            _registeredCount = 0;
            _pool = ArrayPool<Vec2D>.Shared;
            _currentArray = _pool.RentOrGetEmpty(startingCapacity);
            _disposed = false;
        }

        public void Dispose()
        {
            // Dispose of unmanaged resources.
            Dispose(true);
            // Suppress finalization.
            //GC.SuppressFinalize(this);
        }
        protected void Dispose(bool disposing)
        {
            if (_disposed)
                return;

            _pool.ReleaseAndSetAsEmpty(ref _currentArray);
            _disposed = true;
        }
        /*
        //private Vec2D[] CreateNewArray(int length) => new Vec2D[length];
        private Vec2D[] RentArray(int length)
        {
            if (length < 0)
                Guard.Throw.ArgumentLengthCannotBeNegative();
            if (length == 0)
                return Array.Empty<Vec2D>();
            return _pool.Rent(length);
        }
        private void ReleaseArray(ref Vec2D[] array)
        {
        if(array == null || array.Length == 0)
            return;
        _pool.Return(array);
        array = Array.Empty<Vec2D>();
        }
        */

    }
}
