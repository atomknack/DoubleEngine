//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;


namespace DoubleEngine
{
    public sealed class EverGrowingRegistryEnchanced<T,TConverted>: IRegistry<T>
        where T : IEquatable<T>, IConvertibleToOut<TConverted> 
        where TConverted : IConvertibleToOut<T>    {
        public static EverGrowingRegistryEnchanced<T,TConverted> Shared { get { return GetInstance(); } }
        public static EverGrowingRegistryEnchanced<T,TConverted> Create(int startingCapacity = 100) => new EverGrowingRegistryEnchanced< T, TConverted >(startingCapacity);

        private int _registeredCount;
        private T[] _currentArray;
        private ConcurrentDictionary<T, int> _allElements;
        private static EverGrowingRegistryEnchanced<T,TConverted> _instance = null;
        private static object _lock = new object();
        
        private TConverted[] _convertedArray;
        public TConverted GetItemTConverted(RegistryIndex index)=> _convertedArray[index.Value];
        public ReadOnlySpan<TConverted> SnapshotConverted() => new ReadOnlySpan<TConverted>(_convertedArray, 0, _registeredCount);
        //public int GetOrAdd(TConverted item) => GetOrAdd(item.ConvertTo(out _));
        public TConverted[] AssembleIndicesConverted(ReadOnlySpan<RegistryIndex> indexes)
        {
        TConverted[] items = new TConverted[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _convertedArray[indexes[i].Value];
        return items;
        }
        public TConverted[] AssembleIndicesConverted(RegistryIndex[] indexes)
        {
        TConverted[] items = new TConverted[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _convertedArray[indexes[i].Value];
        return items;
        }
        public TConverted[] AssembleIndicesConverted(List<RegistryIndex> indexes)
        {
        TConverted[] items = new TConverted[indexes.Count];
        for(int i=0; i<indexes.Count; i++)
            items[i] = _convertedArray[indexes[i].Value];
        return items;
        }
        public TConverted[] AssembleIndicesConverted(IReadOnlyList<RegistryIndex> indexes)
        {
        TConverted[] items = new TConverted[indexes.Count];
        for(int i=0; i<indexes.Count; i++)
            items[i] = _convertedArray[indexes[i].Value];
        return items;
        }
        private static EverGrowingRegistryEnchanced<T,TConverted> GetInstance()
        {
            if (_instance != null)
                return _instance;
            lock (_lock)
            {
                if (_instance == null)
                    _instance = new EverGrowingRegistryEnchanced<T,TConverted>();
                return _instance;
            }
        }
        public T[] AssembleIndices(ReadOnlySpan<RegistryIndex> indexes)
        {
        T[] items = new T[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public T[] AssembleIndices(RegistryIndex[] indexes)
        {
        T[] items = new T[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public T[] AssembleIndices(List<RegistryIndex> indexes)
        {
        T[] items = new T[indexes.Count];
        for(int i=0; i<indexes.Count; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public T GetItem(RegistryIndex index) => _currentArray[index.Value];
        public T this[RegistryIndex index]{ get=> _currentArray[index.Value]; }
        public ReadOnlySpan<T> Snapshot() => new ReadOnlySpan<T>(_currentArray, 0, _registeredCount);
        public RegistryIndex GetOrAdd(T item)
        {
            if (_allElements.TryGetValue(item, out int found))
                return new RegistryIndex(found);
            lock (_lock) //this implementation is slowish but should be bulletproof
            { 
                if (_allElements.TryGetValue(item, out int insideLock))
                    return new RegistryIndex(insideLock);
                int newElementIndex = AddToArrayInsideLock(item);
                if (_allElements.TryAdd(item, newElementIndex))
                    return new RegistryIndex(newElementIndex);
                throw new Exception("Cannot add element to ConcurrentDictionary inside lock, this should newer happen, program should be terminated");
            }

            int AddToArrayInsideLock(T item)
            {
                int newElementIndex = _registeredCount;
                if (newElementIndex >= _currentArray.Length)
                {
                    int newArraysSize = newElementIndex * 2;
                    T[] newArray = new T[newArraysSize];
                    Array.Copy(_currentArray, newArray, _currentArray.Length);
                    _currentArray = newArray;
                    TConverted[] newConvertedArray = new TConverted[newArraysSize];
                    Array.Copy(_convertedArray, newConvertedArray, _convertedArray.Length);
                    _convertedArray = newConvertedArray;
                }
                _currentArray[newElementIndex] = item;
                _convertedArray[newElementIndex] = item.ConvertTo(out TConverted _);
                _registeredCount++;
                return newElementIndex;
            }
        }
        protected EverGrowingRegistryEnchanced(int startingCapacity = 100)
        {
            _registeredCount = 0;
            _currentArray = new T[startingCapacity];
            _allElements = new();
            _convertedArray = new TConverted[startingCapacity];
        }
    }
}
