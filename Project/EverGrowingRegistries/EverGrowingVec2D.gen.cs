//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using CollectionLike.Comparers.SetsWithCustomComparer;

namespace DoubleEngine
{
    public sealed class EverGrowingVec2D: IRegistry<Vec2D>
    {
        public static EverGrowingVec2D Shared { get { return GetInstance(); } }
        public static EverGrowingVec2D Create(int startingCapacity = 100) => new EverGrowingVec2D(startingCapacity);

        private int _registeredCount;
        private Vec2D[] _currentArray;
        private ConcurrentDictionary<Vec2D, int> _allElements;
        private static EverGrowingVec2D _instance = null;
        private static object _lock = new object();
        
        private static EverGrowingVec2D GetInstance()
        {
            if (_instance != null)
                return _instance;
            lock (_lock)
            {
                if (_instance == null)
                    _instance = new EverGrowingVec2D();
                return _instance;
            }
        }
        public Vec2D[] AssembleIndices(ReadOnlySpan<RegistryIndex> indexes)
        {
        Vec2D[] items = new Vec2D[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public Vec2D[] AssembleIndices(RegistryIndex[] indexes)
        {
        Vec2D[] items = new Vec2D[indexes.Length];
        for(int i=0; i<indexes.Length; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public Vec2D[] AssembleIndices(List<RegistryIndex> indexes)
        {
        Vec2D[] items = new Vec2D[indexes.Count];
        for(int i=0; i<indexes.Count; i++)
            items[i] = _currentArray[indexes[i].Value];
        return items;
        }
        public Vec2D GetItem(RegistryIndex index) => _currentArray[index.Value];
        public Vec2D this[RegistryIndex index]{ get=> _currentArray[index.Value]; }
        public ReadOnlySpan<Vec2D> Snapshot() => new ReadOnlySpan<Vec2D>(_currentArray, 0, _registeredCount);
        public RegistryIndex GetOrAdd(Vec2D item)
        {
            if (_allElements.TryGetValue(item, out int found))
                return new RegistryIndex(found);
            lock (_lock) //this implementation is slowish but should be bulletproof
            { 
                if (_allElements.TryGetValue(item, out int insideLock))
                    return new RegistryIndex(insideLock);
                int newElementIndex = AddToArrayInsideLock(item);
                if (_allElements.TryAdd(item, newElementIndex))
                    return new RegistryIndex(newElementIndex);
                throw new Exception("Cannot add element to ConcurrentDictionary inside lock, this should newer happen, program should be terminated");
            }

            int AddToArrayInsideLock(Vec2D item)
            {
                int newElementIndex = _registeredCount;
                if (newElementIndex >= _currentArray.Length)
                {
                    int newArraysSize = newElementIndex * 2;
                    Vec2D[] newArray = new Vec2D[newArraysSize];
                    Array.Copy(_currentArray, newArray, _currentArray.Length);
                    _currentArray = newArray;
                }
                _currentArray[newElementIndex] = item;
                _registeredCount++;
                return newElementIndex;
            }
        }
        protected EverGrowingVec2D(int startingCapacity = 100)
        {
            _registeredCount = 0;
            _currentArray = new Vec2D[startingCapacity];
            _allElements = new(Vec2DComparer_2em5.ComparerInstance);

        }
    }
}
